1. in the early days, one computer has one console; and many terminals can
   connect to it; the console can be considerd as a special termial: startup
   messages, printk outputs are seen on console but not on termials;

2. Now: 
   a. /dev/tty1 to /dev/tty63 simulates those terminals, so they are called
      'virtual terminals' or 'controlling terminals';

   b. any one of /dev/tty1 to /dev/tty6 can assume the role of console:
            chvt N   //1 <= N <= 6,  let ttyN be the console;
      for example, 'chvt 3', then /dev/console stands for /dev/tty3

   c. /dev/console stands for the console;

   d. /dev/tty0: alias of the tty who is assuming the role of console (e.g.
      /dev/tty3); so it's the same as /dev/console;

      for example: tty3 is assuming the role of console;
          echo xx > /dev/tty3
          echo xx > /dev/console
          echo xx > /dev/tty0
      will print 'xx' on screen;
     
   e. /dev/tty: termial of current process; notice that /dev/console and /dev/tty0 
      are for the system, while /dev/tty is for current process;


3. Moreover, we can have more than one consoles, one for each type:
            console=ttyS2,tty1   //kernel parameters
   in this case:
       a. startup messages, printk outputs are seen on both consoles;
       b. echo x > /dev/console, 'x' is shown on both consoles;
       c. but only the last console can input;

                         /dev/console --------------------------------+
                         /dev/tty0                                    |
                              |                                       |
                              |                                       |
                              V                                       |
            +----------> /dev/tty1  ....  physical VGA console    <---+
 virtual    |            /dev/tty2                                    |
 terminals  |            /dev/tty3                                    |
            |            ...                                          |
            +----------> /dev/tty63                                   |
                                                                      | 
            +----------> /dev/ttyS0                                   | 
 serial     |            /dev/ttyS1                                   |
 ports      |            /dev/ttyS2 ..... physical Serial console <---+
            +----------> /dev/ttyS3

            +----------> /dev/pts/0
pseudo      |            /dev/pts/1
termials    |            /dev/pts/2
 SSH        |            ...
 Telnet     +----------> /dev/pts/N
 GUI
      


------------------------------------------------------------------------------------

user              fork                                    pthread_create 
programe           |                                            |
                   |                                            |
                   V                                            V
libc              fork                                    pthread_create
                   |                                            |
                   |                                            |
                   |                                            |
              child_stack=0,                            child_stack=0x7fa8c0d41fb0, 
              flags=CLONE_CHILD_CLEARTID                flags=CLONE_VM
                    CLONE_CHILD_SETTID                        CLONE_FS
                    SIGCHLD,                                  CLONE_FILES
              child_tidptr=0x7f9e00902a10                     CLONE_SIGHAND
                   |                                          CLONE_THREAD
                   |                                          CLONE_SYSVSEM
                   |                                          CLONE_SETTLS
                   |                                          CLONE_PARENT_SETTID
                   |                                          CLONE_CHILD_CLEARTID, 
                   |                                    parent_tidptr=0x7fa8c0d429d0, 
                   |                                    tls=0x7fa8c0d42700,<-----------+
                   |                                    child_tidptr=0x7fa8c0d429d0    |
                   |                                             |                     |
                   |                                             |                     |
                   |                                             |                     |
                   |                                             |                     |
                   +--------------------+------------------------+                     |
                                        |                           parent:  pthread_create(pthread_t*)
                                        |                           child:   pthread_self()
                                        |
                                        |
                                        V
SYSCALL               fork    vfork   clone 
                        |       |       |
                        |       |       |
                        +-------+-------+
                                |
                                |
                                V
                             do_fork



                                    files_struct
    thread1   -----+---------->  +-----------------+
      |            ^             | count = 2       |
      |            |             |                 |
      |            |             |    fdtable      |
      |            |             | +-------------+ |
      |            |             | |struct file *| |
      |            |             | +-------------+ |         file
      |            |             | |struct file *| | ---> +----------+
      |            |             | +-------------+ |      |f_count=1 |
      V            |             | |struct file *| |      |......    |
pthread_create     |             | +-------------+ |      +----------+
      |            |             |     ......      |
      |            |             | +-------------+ |
      |            |             | |struct file *| |
      |            |             | +-------------+ |
      |            |             +-----------------+
      |            |
      |            |
      |            |
      |            |
      V            |
    thread2  ----->+


                                    files_struct
    process1  ---------------->  +-----------------+
      |                          | count = 1       |
      |                          |                 |
      |                          |    fdtable      |
      |                          | +-------------+ |
      |                          | |struct file *| |
      |                          | +-------------+ |                     file      
      |                          | |struct file *| | -------+-------> +----------+
      |                          | +-------------+ |        ^         |f_count=2 |
      V                          | |struct file *| |        |         |......    |
     fork                        | +-------------+ |        |         +----------+
      |                          |     ......      |        |
      |                          | +-------------+ |        |
      |                          | |struct file *| |        |
      |                          | +-------------+ |        |
      |                          +-----------------+        |
      |                                                     |
      |                                                     |
      |                                                     |
      V                             files_struct            |
    process2 ------------------> +-----------------+        |
                                 | count = 1       |        |
                                 |                 |        |
                                 |    fdtable      |        |
                                 | +-------------+ |        |
                                 | |struct file *| |        |
                                 | +-------------+ |        |
                                 | |struct file *| | ------>+
                                 | +-------------+ |
                                 | |struct file *| |
                                 | +-------------+ |
                                 |     ......      |
                                 | +-------------+ |
                                 | |struct file *| |
                                 | +-------------+ |
                                 +-----------------+
                                 

close()函数： f_count--, 直到0才真正关闭。所以:
    多线程中close，会真正close();
    多进程中close，最后一个进程调用时，才真正close();
shutdown()函数：直接关闭，与计数无关，与多线程多进程无关；


------------------------------------------------------------------------------------

diskstats_show            block/genhd.c
blk_account_io_done       block/blk-core.c
part_round_stats_single   block/blk-core.c


driver 
 --> blk_init_queue
       --> blk_init_queue_node
            --> blk_init_allocated_queue
                --> blk_queue_make_request
                    make_request_fn = blk_queue_bio;

generic_make_request  -->
  make_request_fn (blk_queue_bio)
      --> add_acct_request 
          --> blk_account_io_start 
              -->  part_round_stats 
                  --> part_round_stats_single




blk_finish_request   -->  blk_account_io_done  --> part_round_stats  --> part_round_stats_single



+----------------------------------- buffer cache (block cache)----------------------------------+
|                                               |                                                |
| __bread                                       | ll_rw_block(rw, nr, *bhs[])                    |
|    A. bh = __getblk_gfp                       |  for each block in bhs                         |
|        1. bh = __find_get_block               |    A. bh->b_end_io = end_buffer_read_sync      |
|        2. if bh != NULL, return bh;           |                   or end_buffer_write_sync     |
|        3. call grow_buffers to alloc,         |    B. call submit_bh                           |                  
|           and return (data not read)          |       1. prepare bio struct;                   | 
|    B. if bh.BH_Uptodate is set (data is read  |          bio->bi_end_io = end_bio_bh_io_sync   |    
|       and uptodate), return bh;               |          ......                                |
|    C. bh->b_end_io = end_buffer_read_sync     |       2. call submit_bio() of the              |
|    D. call submit_bh(READ, bh) to read data   |          generic block layer;                  |
|        1. prepare bio struct;                 |                                                |
|           bio->bi_end_io = end_bio_bh_io_sync |                                                |
|           ......                              |                                                |
|        2. call submit_bio() of the            |                                                |
|           generic block layer;                |                                                |
|                                               |                                                |

------------------------------------------------------------Generic Block Layer----------------------------------------------------------

1. Generic Block Layer

1.1 struct bio

                               struct bio
                     
                              | ...   |            | ...    |
                              +-------+            +--------+
               +--- segment0  |pageN  | ---------> |blockX  |
               |              +-------+            +--------+ 
 physical ---> +--- segment1  |pageN+1| ---------> |blockX+1|
 segment       |              +-------+            +--------+
               +--- segment2  |pageN+2| ---------> |blockX+2|
                              +-------+            +--------+
                                ...       +------> |blockX+3|
                              +-------+   |        +--------+
 physical --------> segment3  |pageM  | --+ +----> |blockX+4|
 segment                      +-------+     |      +--------+
                                ...         |      | ...    |
                              +-------+     |      
 physical --------> segment4  |pageP  | ----+      
 segment                      +-------+            
                              | ...   |
                            
                          page-size    = 4KB
                          block-size   = 4KB
                          segment-size = 4KB (block <= segment <= page)





1.2 struct gendisk 


1.3 interfaces

                                 
submit_bio(rw, bio)             |     generic_make_request(bio)           
   1. some cpu/process level    |           1. generic_make_request_checks 
      accouting.                |                 a. do some check work;
   2. generic_make_request      |                 b. blk_partition_remap
                                |           2. if current->bio_list is NOT null, that means
                                |              a make_request_fn is active, we don't want
                                |              to start a new one, so:
                                |                 a. add bio to current->bio_list;
                                |                 b. return;
                                |           3. current->bio_list is null. no make_request_fn
                                |              is active, so start one: 
                                |                 a. init current->bio_list to an empty list; 
                                |                 b. make_request_fn(..., bio)
                                |                 c. bio = pop current->bio_list
                                |                 d. if bio != null, goto 3.b
                                | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                                |      question: current->bio_list is initialized to empty in 3.a,
                                |                how can 3.c and 3.d pop a non-null bio from it?
                                |      answer:   3.b may call generic_make_request recursively (
                                |                due to multi layers of block), in that case, the
                                |                recursive call will put a bio in step 2 and return,
                                |                thus the outer call may pop a non-null bio in 3.c;
                                       


---------------------------------------------------------------------------------------------------------------------

2. IO Scheduler Layer





--------------------------------------------------------------------------------------------------
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  IO Schedule layer  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
--------------------------------------------------------------------------------------------------
