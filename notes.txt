1. in the early days, one computer has one console; and many terminals can
   connect to it; the console can be considerd as a special termial: startup
   messages, printk outputs are seen on console but not on termials;

2. Now, /dev/tty1 to /dev/tty63 simulates those terminals, so they are called
   virtual terminals; 

3. One of /dev/tty1 to /dev/tty6 can assume the role of console:
            chvt N   //1 <= N <= 6 tty1-tty6 can be used as console;

4. Moreover, we can have more than one consoles, one for each type:
            console=ttyS2,tty1   //kernel parameters
   in this case:
       a. startup messages, printk outputs are seen on both consoles;
       b. echo x > /dev/console, 'x' is shown on both consoles;
       c. but only the last console can input;

                         /dev/console --------------------------------+
                         /dev/tty0                                    |
                              |                                       |
                              |                                       |
                              V                                       |
            +----------> /dev/tty1  ....  physical VGA console    <---+
 virtual    |            /dev/tty2                                    |
 terminals  |            /dev/tty3                                    |
            |            ...                                          |
            +----------> /dev/tty63                                   |
                                                                      | 
            +----------> /dev/ttyS0                                   | 
 serial     |            /dev/ttyS1                                   |
 ports      |            /dev/ttyS2 ..... physical Serial console <---+
            +----------> /dev/ttyS3

            +----------> /dev/pts/0
pseudo      |            /dev/pts/1
termials    |            /dev/pts/2
 SSH        |            ...
 Telnet     +----------> /dev/pts/N
 GUI
      


diskstats_show            block/genhd.c
blk_account_io_done       block/blk-core.c
part_round_stats_single   block/blk-core.c


driver 
 --> blk_init_queue
       --> blk_init_queue_node
            --> blk_init_allocated_queue
                --> blk_queue_make_request
                    make_request_fn = blk_queue_bio;

generic_make_request  -->
  make_request_fn (blk_queue_bio)
      --> add_acct_request 
          --> blk_account_io_start 
              -->  part_round_stats 
                  --> part_round_stats_single




blk_finish_request   -->  blk_account_io_done  --> part_round_stats  --> part_round_stats_single







------------------------------------------------------------------------------------------------
                                       Generic Block Layer
------------------------------------------------------------------------------------------------
//                               struct bio
//                     
//                              | ...   |            | ...    |
//                              +-------+            +--------+
//               +--- segment0  |pageN  | ---------> |blockX  |
//               |              +-------+            +--------+ 
// physical ---> +--- segment1  |pageN+1| ---------> |blockX+1|
// segment       |              +-------+            +--------+
//               +--- segment2  |pageN+2| ---------> |blockX+2|
//                              +-------+            +--------+
//                                ...       +------> |blockX+3|
//                              +-------+   |        +--------+
// physical --------> segment3  |pageM  | --+ +----> |blockX+4|
// segment                      +-------+     |      +--------+
//                                ...         |      | ...    |
//                              +-------+     |      
// physical --------> segment4  |pageP  | ----+      
// segment                      +-------+            
//                              | ...   |
//                            
//                          page-size    = 4KB
//                          block-size   = 4KB
//                          segment-size = 4KB (block <= segment <= page)







-------------------------------------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  Generic block layer  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------------------------------------------------------------------------------------------------
                                 
submit_bio(rw, bio)             |     generic_make_request(bio)           
   1. some cpu/process level    |           1. generic_make_request_checks 
      accouting.                |                 a. do some check work;
   2. generic_make_request      |                 b. blk_partition_remap
                                |           2. if current->bio_list is NOT null, that means
                                |              a make_request_fn is active, we don't want
                                |              to start a new one, so:
                                |                 a. add bio to current->bio_list;
                                |                 b. return;
                                |           3. current->bio_list is null. no make_request_fn
                                |              is active, so start one: 
                                |                 a. init current->bio_list to an empty list; 
                                |                 b. make_request_fn(..., bio)
                                |                 c. bio = pop current->bio_list
                                |                 d. if bio != null, goto 3.b
                                | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                                |      question: current->bio_list is initialized to empty in 3.a,
                                |                how can 3.c and 3.d pop a non-null bio from it?
                                |      answer:   3.b may call generic_make_request recursively (
                                |                due to multi layers of block), in that case, the
                                |                recursive call will put a bio in step 2 and return,
                                |                thus the main call can pop a non-null bio in 3.c;
                                       
--------------------------------------------------------------------------------------------------
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Generic block layer  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
--------------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  IO Schedule layer  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-------------------------------------------------------------------------------------------------



--------------------------------------------------------------------------------------------------
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  IO Schedule layer  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
--------------------------------------------------------------------------------------------------
